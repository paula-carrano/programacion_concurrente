-------- EJERCICIO 1 --------
A) ESQUEMA BASICO

global int suma = 0
global int impar
global int i = 1
global int N // Debe inicializarse antes de lanzar los hilos

Semaphore puedoGenerar = new Semaphore(1)  //Permite entrar en la primera al generador
Semaphore puedoAcumular = new Semaphore(0) // bloquea al acumulador

thread generador{
    while(true) {
        puedoGenerar.acquire()              // pide permiso para "producir"
        if (i > N){                         // Si i > N entonces termino de "producir"
            impar = -1                      // uso sentinel para marcar el "fin de producción"
            puedoAcumular.release()         // Intenta "despertar" al acumulador
            return
        }
        impar = i
        i = i + 1                           // incrementa i para la proxima producción
        puedoAcumular.release()             // indica al acumulador que hay dato para listo.
    }
}

thread acumulador {
    while(true) {
        puedoAcumular.acquire()             // espera hasta que haya algo para consumir
        if (impar == -1) return             // ya no hay más datos
        int valor = 2 * impar - 1
        suma = suma + valor
        puedoGenerar.release()
    }
}

B)
    I. ESQUEMA CON MULTIPLES THREADS GENERADOR

global Object[] colaImpares = new Object[N]
global int N
global int suma            = 0
global int indiceLectura   = 0
global int indiceEscritura = 0
global int siguienteImpar  = 1       // próximo impar a generar
global int NUM_ACUMULADORES         // Debe definirse según la cantidad de acumuladores

Semaphore accesoCola = new Semaphore(1)         // protege la cola
Semaphore espaciosLibres = new Semaphore(N)     // espacios disponibles en la cola
Semaphore datosDisponibles = new Semaphore(0)   // cantidad de impares listos

thread generador {
    while (true) {
        espaciosLibres.acquire()
        accesoCola.acquire()
            if (siguienteImpar > N) {
                // PonEMOS un sentinel por cada acumulador
                for (int k = 0; k < NUM_ACUMULADORES; k++) {
                    colaImpares[indiceEscritura] = -1
                    indiceEscritura = (indiceEscritura + 1) mod N
                    datosDisponibles.release()
                }
                accesoCola.release()
                return
            }
            colaImpares[indiceEscritura] = siguienteImpar
            indiceEscritura = (indiceEscritura + 1) mod N
            siguienteImpar = siguienteImpar + 1
        accesoCola.release()
        datosDisponibles.release()
    }
}

thread acumulador {
    while (true) {
        datosDisponibles.acquire()      // espera que haya dato
        accesoCola.acquire()            // acceso exclusivo a la cola
            int valor = colaImpares[indiceLectura]
            indiceLectura = (indiceLectura + 1) mod N
        accesoCola.release()
        espaciosLibres.release()        // libera espacio en la cola

        if (valor == -1) return        // fin de producción

        suma = suma + (2 * valor - 1)
    }
}

 ####   II. ESQUEMA CON MULTIPLES THREADS ACUMULADOR   ####

global Object[] colaImpares = new Object[N]
global int N
global int suma             = 0
global int indiceLectura    = 0
global int indiceEscritura  = 0
global int siguienteImpar   = 1       // próximo impar a generar
global int NUM_ACUMULADORES         // Debe definirse según la cantidad de acumuladores

Semaphore accesoCola       = new Semaphore(1)
Semaphore espaciosLibres   = new Semaphore(N)
Semaphore datosDisponibles = new Semaphore(0)
Semaphore accesoSuma       = new Semaphore(1)     // protege la suma cuando hay múltiples acumuladores

thread generador {
    while (true) {
        espaciosLibres.acquire()
        accesoCola.acquire()
            if (siguienteImpar > N) {
                // Se pone un sentinel por cada acumulador
                for (int k = 0; k < NUM_ACUMULADORES; k++) {
                    colaImpares[indiceEscritura] = -1
                    indiceEscritura = (indiceEscritura + 1) mod N
                    datosDisponibles.release()
                }
                accesoCola.release()
                return
            }
            colaImpares[indiceEscritura] = siguienteImpar
            indiceEscritura = (indiceEscritura + 1) mod N
            siguienteImpar += 1
        accesoCola.release()
        datosDisponibles.release()
    }
}

thread acumulador {
    while (true) {
        datosDisponibles.acquire()
        accesoCola.acquire()
            int valor = colaImpares[indiceLectura]
            indiceLectura = (indiceLectura + 1) mod N
        accesoCola.release()
        espaciosLibres.release()

        if (valor == -1) return

        accesoSuma.acquire()
            suma = suma + (2 * valor - 1)
        accesoSuma.release()
    }
}

-------- EJERCICIO 2 --------

Semaphore permisoAbordar = new Semaphore(0,True)
Semaphore asientoOcupado = new Semaphore(0)
Semaphore permisoBajar = new Semaphore(0)
Sempahore permisoVolver = new Semaphore(0) 

thread transbordador {
	while (true){
		permisoAbordar.release()
		asientoOcupado.acquire()
		// navegar 
		permisoBajar.release();
		// regresar
		permisoVolver.acquire();
	}
}

thread persona {
	while(true){
		permisoAbordar.acquire();
		// subir
		asientoOcupado.release();
		permisoBajar.acquire();
		// bajar
		permisoVolver.release();
	}
}


---------- B--------------------

Semaphore permisoAbordar = new Semaphore(0,True)[2]
Semaphore asientoOcupado = new Semaphore(0)
Semaphore permisoBajar = new Semaphore(0)
Sempahore permisoVolver = new Semaphore(0) 

thread transbordador {
	costa = 0
while(true){
	Repeat N:
		permisoAbordar.[costa].release()
	Repeat N:
		asientoOcupado.acquire()
	costa= costa +1 % 2;
	// navegar 
	Repeat N:
		permisoBajar.release();
	// regresar
	Repeat N:
		permisoVolver.acquire();
}
}

thread persona(int costa) {
		permisoAbordar.[costa].acquire();
		// subir
		asientoOcupado.release();
		permisoBajar.acquire();
		// bajar
		permisoVolver.release();
}

C) Trasbordo subir/bajar concurrentemente

Semaphore permisoAbordar = new Semaphore(0,True)[2]
Semaphore asientoOcupado = new Semaphore(0)
Semaphore permisoBajar = new Semaphore(0)
Sempahore permisoVolver = new Semaphore(0) 
Semaphore asiento = new Semaphore(N)

thread transbordador {
	costa = 0
	while(true){
		permisoAbordar.[costa].release(N)

		asientoOcupado.acquire(N)

		costa= costa +1 % 2;

		// navegar 

		permisoBajar[costa].release(N);

		// regresar
	}
}

thread persona(int costa) {
		permisoAbordar.[costa].acquire();
        asiento.acquire();
		// subir
		asientoOcupado.release();
		permisoBajar.[costa +1 % 2].acquire();
		// bajar
        asiento.release();
}


--------------  ejercicio 3

Semaphore maquina[] = new Semaphore[4]; // {1,1,1,1} FUERTE 
Semaphore discos    = new Semaphore(20); 
Semaphore mutexDiscos = new Semaphore(1);  FUERTE


thread Persona(List<int,int> rutina):{


	for (nromaq,cantDiscos in rutina) {
		mutexDiscos.acquire();

		repeat(cantDiscos) {
			discos.acquire();
		}
		mutexDiscos.release();			// va aca para proteger los discos

		maquina[nromaq].acquire();

		//hace ejercicio

		maquina[nromaq].release();
		repeat(cantDiscos) {
			discos.release();
		}
	}
}

----------------------- ejercicio 4 
int maquinaDisponible; 				//BUFFER
Semaphore puedeAnunciarse   = new Semaphore(1); //FUERTE
Semaphore puedeTomarMaquina = new Semaphore(0); //FUERTE
Semaphore ropaCargada[]     = new Semaphore[k];
Semaphore mensajeEnviado[]  = new Semaphore[K];
Semaphore ropaRetirada[]    = new Semaphore[K];

thread Maquina(id): {
	
	while (true){
		puedeAnunciarse.acquire();
		maquinaDisponible = id;
		puedeTomarMaquina.release();
		ropaCargada[id].acquire();

		//LAVAR
		//ENVIAR MENSAJE
		mensajeEnviado[id].release();
		ropaRetirada[id].acquire();
	}

}

thread Persona: {

	int miMaquina;
	puedeTomarMaquina.acquire();
	miMaquina = maquinaDisponible;
	puedeAnunciarse.release();

	//CARGAR ROPA en miMaquina;
	ropaCargada[miMaquina].release();
	// SE VA DE COMPRAS
	mensajeEnviado[miMaquina].acquire();
	//RETIRA LA ROPA
	ropaRetirada[miMaquina].release();
	//SE VA

}


----------------------- ejercicio 5 





------------------------ejercicio 6

--A

Semaphore[]  accesoACancha= new Semaphore[2]: {1,1}


thread Persona(int equipo) {
	equipoOpuesto = (equipo +1) % 2;
	accesoALaCancha[equipo].acquire();
	//ENTRA A LA CANCHA
	accesoALaCancha[equipoOpuesto].release();
	//MIRAR PARTIDO
}


--B

Semaphore[]  accesoACancha= new Semaphore[2]: {1,1}
int capacidadCancha = N;
Semaphore mutexAcceso = new Semaphore(1);


thread Persona(int equipo) {
	equipoOpuesto = (equipo +1) % 2;
	accesoALaCancha[equipo].acquire();

	mutexAcceso.acquire();

	if (capacidadCancha > 0){ 
	
		capacidadCancha--;
		mutexAcceso.release();

		//ENTRA A LA CANCHA
		accesoALaCancha[equipoOpuesto].release();

		if(capacidadCancha == 0) {
		accesoALaCancha[miEquipo].release();
		}
		//MIRAR PARTIDO
	}
	else {
		mutexAcceso.release();
		accesoALaCancha[miEquipo].release();
		//VOLVER A CASA
	}
}