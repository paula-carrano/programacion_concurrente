-------- EJERCICIO 1 --------
A) ESQUEMA BASICO

global int suma = 0
global int impar
global int i = 1
global int N // Debe inicializarse antes de lanzar los hilos

Semaphore puedoGenerar = new Semaphore(1)  //Permite entrar en la primera al generador
Semaphore puedoAcumular = new Semaphore(0) // bloquea al acumulador

thread generador{
    while(true) {
        puedoGenerar.acquire()              // pide permiso para "producir"
        if (i > N){                         // Si i > N entonces termino de "producir"
            impar = -1                      // uso sentinel para marcar el "fin de producción"
            puedoAcumular.release()         // Intenta "despertar" al acumulador
            return
        }
        impar = i
        i = i + 1                           // incrementa i para la proxima producción
        puedoAcumular.release()             // indica al acumulador que hay dato para listo.
    }
}

thread acumulador {
    while(true) {
        puedoAcumular.acquire()             // espera hasta que haya algo para consumir
        if (impar == -1) return             // ya no hay más datos
        int valor = 2 * impar - 1
        suma = suma + valor
        puedoGenerar.release()
    }
}

B)
    I. ESQUEMA CON MULTIPLES THREADS GENERADOR

global Object[] colaImpares = new Object[N]
global int N
global int suma            = 0
global int indiceLectura   = 0
global int indiceEscritura = 0
global int siguienteImpar  = 1       // próximo impar a generar
global int NUM_ACUMULADORES         // Debe definirse según la cantidad de acumuladores

Semaphore accesoCola = new Semaphore(1)         // protege la cola
Semaphore espaciosLibres = new Semaphore(N)     // espacios disponibles en la cola
Semaphore datosDisponibles = new Semaphore(0)   // cantidad de impares listos

thread generador {
    while (true) {
        espaciosLibres.acquire()
        accesoCola.acquire()
            if (siguienteImpar > N) {
                // PonEMOS un sentinel por cada acumulador
                for (int k = 0; k < NUM_ACUMULADORES; k++) {
                    colaImpares[indiceEscritura] = -1
                    indiceEscritura = (indiceEscritura + 1) mod N
                    datosDisponibles.release()
                }
                accesoCola.release()
                return
            }
            colaImpares[indiceEscritura] = siguienteImpar
            indiceEscritura = (indiceEscritura + 1) mod N
            siguienteImpar = siguienteImpar + 1
        accesoCola.release()
        datosDisponibles.release()
    }
}

thread acumulador {
    while (true) {
        datosDisponibles.acquire()      // espera que haya dato
        accesoCola.acquire()            // acceso exclusivo a la cola
            int valor = colaImpares[indiceLectura]
            indiceLectura = (indiceLectura + 1) mod N
        accesoCola.release()
        espaciosLibres.release()        // libera espacio en la cola

        if (valor == -1) return        // fin de producción

        suma = suma + (2 * valor - 1)
    }
}

 ####   II. ESQUEMA CON MULTIPLES THREADS ACUMULADOR   ####

global Object[] colaImpares = new Object[N]
global int N
global int suma             = 0
global int indiceLectura    = 0
global int indiceEscritura  = 0
global int siguienteImpar   = 1       // próximo impar a generar
global int NUM_ACUMULADORES         // Debe definirse según la cantidad de acumuladores

Semaphore accesoCola       = new Semaphore(1)
Semaphore espaciosLibres   = new Semaphore(N)
Semaphore datosDisponibles = new Semaphore(0)
Semaphore accesoSuma       = new Semaphore(1)     // protege la suma cuando hay múltiples acumuladores

thread generador {
    while (true) {
        espaciosLibres.acquire()
        accesoCola.acquire()
            if (siguienteImpar > N) {
                // Se pone un sentinel por cada acumulador
                for (int k = 0; k < NUM_ACUMULADORES; k++) {
                    colaImpares[indiceEscritura] = -1
                    indiceEscritura = (indiceEscritura + 1) mod N
                    datosDisponibles.release()
                }
                accesoCola.release()
                return
            }
            colaImpares[indiceEscritura] = siguienteImpar
            indiceEscritura = (indiceEscritura + 1) mod N
            siguienteImpar += 1
        accesoCola.release()
        datosDisponibles.release()
    }
}

thread acumulador {
    while (true) {
        datosDisponibles.acquire()
        accesoCola.acquire()
            int valor = colaImpares[indiceLectura]
            indiceLectura = (indiceLectura + 1) mod N
        accesoCola.release()
        espaciosLibres.release()

        if (valor == -1) return

        accesoSuma.acquire()
            suma = suma + (2 * valor - 1)
        accesoSuma.release()
    }
}

-------- EJERCICIO 2 --------

A) Trasbordo simple

global Object[] colaPersonas = new Object[N]
Semaphore espaciosLibres     = new Semaphore(N)
Semaphore personasEsperando  = new Semaphore(0)
Semaphore accesoACola        = new Semaphore(1)
global int indiceL = 0
global int indiceE = 0

thread transbordador {
    while(true){
        personasEsperando.acquire();
        accesoACola.acquire();
        id = colaPersonas[indiceL];
        indiceL = (indiceL + 1) mod N;
        accesoACola.release();

        cruzarRio();                 // simula el cruce
        bajarPersona(id);            // simula que la persona baja
        regresar();                  // simula el regreso

        espaciosLibres.release();
    }
}

thread persona {
    espaciosLibres.acquire();
    accesoACola.acquire();
        colaPersonas[indiceE] = id;
        indiceE = (indiceE + 1) mod N;
    accesoACola.release();

    personasEsperando.release();
}



B) TRASLADO DE OESTE A ESTE (Barco zarpa con menos de N pasajeros)

global int N
global int personasEnBarco = 0
global int CostaActual     = 0          // 0 = Oeste && 1 = Este
global int esperandoEnCosta[2] = {0, 0} // cantidad de pasajeros esperando en cada costa

Semaphore mutexBarco    = new Semaphore(1)                          // protege personasEnBarco y costaActual
Semaphore puedenSubir[2]= [new Semaphore(0), new Semaphore(0)]      // por costa
Semaphore puedenBajar   = new Semaphore(0)                          // permite bajar cuando el barco amarra
Semaphore viajeTerminado= new Semaphore(0)                          // sinc el fin del viaje
Semaphore zarpar        = new Semaphore(0)                          // indica que el barco puede zarpar

thread transbordador {
    while (true) {
        mutexBarco.acquire()
            int pasajerosSuben = min(N, esperandoEnCosta[CostaActual])
            for (int i = 0; i < pasajerosSuben; i++)
                puedenSubir[CostaActual].release()
        mutexBarco.release()

        // Espera a que suban todos los que pueden
        for (int i = 0; i < pasajerosSuben; i++)
            viajeTerminado.acquire()

        cruzarRio()
        CostaActual = 1 - CostaActual

        for (int i = 0; i < personasEnBarco; i++)
            puedenBajar.release()

        for (int i = 0; i < personasEnBarco; i++)
            viajeTerminado.acquire()

        // Reinicia el contador de personas en el barco
        personasEnBarco = 0
    }
}

thread persona(id, costaInicial) {
    while (true) {
        mutexBarco.acquire()
            esperandoEnCosta[costaInicial] = esperandoEnCosta[costaInicial] + 1
        mutexBarco.release()

        puedenSubir[costaInicial].acquire()

        mutexBarco.acquire()
            personasEnBarco = personasEnBarco + 1
            esperandoEnCosta[costaInicial] = esperandoEnCosta[costaInicial] - 1
        mutexBarco.release()

        viajeTerminado.release()
        puedenBajar.acquire()

        mutexBarco.acquire()
            personasEnBarco = personasEnBarco - 1
        mutexBarco.release()

        viajeTerminado.release()
        costaInicial = 1 - costaInicial
    }
}

-------- EJERCICIO 3 --------

global int TOTAL_DISCOS      = 20;
global Semaphore discos      = new Semaphore(totalDeDiscos)
global Semaphore aparatos[4] = { new Semaphore(1), new Semaphore(1), new Semaphore(1), new Semaphore(1) }

thread Cliente {
        // se puede usar foreach??!
}