TODAS LAS TRAZAS DEMOSTRADAS ESTAN EL ARCHIVO EXCEL.

                                                            EJERCICIO 1


a) Posibles valores de x = {1, 2, 3, 4, 5, 6} dependiendo del entrelazado. No se cumple mutex porque todos entran en el while por ser false.

b) La operación no es atómica por lo que ambos pueden hacer que ocupado = True incumpliendo la propiedad de mutex. Generando starvation.

c) Si son atómicas, entrar no tiene interleaving. Además garantiza que solo un thread logre entrar. El resto verá ocupado = true.
    entrar() es equivalente a testAndSet() de la teorica => demostrarlo con que parte pertenece a cada uno. Como en la teorica esta demostrado ya esta

                                        ----------------------------------------------------------
                                                            EJERCICIO 2     

global int actual = 0, turnos = 0;

 PedirTurno() {                                 LiberarTurno() {
    int turno = turnos;                            turnos = turnos -1;
    turnos = turnos + 1;                        }
    return turno;
 }

 // seccion no critica
 miTurno = PedirTurno();
 while (actual != miTurno);
 // seccion critica
 LiberarTurno();
 // seccion no critica

En ningún lado se incrementa la variable actual, se inicializa en 0 y nunca cambia.
El while (actual != miTurno) depende de actual para permitir asignar al siguiente turno. Produciendo un deadlock.
Además LiberarTurno() decrementa turnos, no actual. 

MUTEX: podría cumplirse si miTurno == 0 , pero se da porque se produce un bloqueo del resto.

GARANTIA DE ENTRADA: No se cumple porque los threads > 0 quedarían en loop generando un deadlock.

                                        ----------------------------------------------------------
                                                            EJERCICIO 3    
tomarFlag(mia, otro) {
    flags[mia] = !flags[otro];
}

global boolean[] flags = {false, false};

thread { // threadId=0                                  thread { // threadId=1
    while (!flags[0])                                         while (!flags[1]) 
    tomarFlag(0,1);                                           tomarFlag(1,0);
    // seccion critica                                         // seccion critica
    flags[0] = false;                                         flags[1] = false;
}                                                       }


 A) tomarFlag NO ES ATÓMICA => 
    
    ** No se cumple MUTEX porque potencialmente podrían entrar juntas a SC.
        Ambos threads pueden quedar flags[0] = true y  flags[1] = true; ya que tomarFlag() tiene que leer flags[otro] y luego calcular la negación y asignar en flags[mia]

    ** No se cumple la garantia de entrada porque podría producirse un deadlock y nadie entra a la SC aunque este libre.
        THREAD PROBADO EN ARCHIVO TRAZAS.

 B) tomarFlag ES ATÓMICA
    ** Se cumple MUTEX y GARANTIA DE ENTRADA porque no hay interleaving
        Ejemplo: 
        T0 = analiza la condición => flags[0] = !false = true -> (true, false)
        T1 = analiza la condición => flags[1] = !true = false -> (true, false)
        T0 sale del while, por ende entra al SC y T1 se queda esperando, garantizando que solo uno este dentro (MUTEX).
        Cuando termina T0, flags[0] = false por lo que eventualmente entra en el SC. (GARANTIA DE ENTRADA)

        
    
                                        ----------------------------------------------------------
                                                            EJERCICIO 4  

 void Exchange(Ref sref, Ref lref) {
    temp       = sref.value;        // temp = false
    sref.value = lref.value;        // shared= true
    lref.value = temp;              // local= false
 }

 global Ref shared = new Ref(false); // shared = false
 
 thread {
    Ref local = new Ref(true);      // local = true
        // seccion no critica
    
    do { Exchange(shared, local);  // do - while se ejecuta el do una vez, después entra en el while
    } while (local.value);          
    
        // seccion critica
    shared.value = false;
        // seccion no critica
 }

MUTEX: porque mientras un thread esta en el SC, el shared.value = true por lo que el local.value = false. Y si entra otro thread, se queda esperando por el valor del shared.

GARANTIA DE ENTRADA: Siempre algún thread entra: cuando shared=false, en el próximo Exchange alguien logrará llevarse false a su local y pasar al SC.
Pero no está garantizado que todos entren. Supongamos cantidad no acotada de threads: puede pasar que el mismo thread (ej. T1) consiga reiteradamente el shared=false y entre muchas veces, dejando a otros (T2, T3, …) esperando para siempre.


                                        ----------------------------------------------------------
                                                            EJERCICIO 5 
global int ticket = 0;
global int turn = 0;

thread T1: {                                        thread T2 {
    // NSC                                              // NSC
    int myTurn = getTurn();   1                          int myTurn = getTurn();
    while (myTurn != turn);                             while (myTurn != turn);
    // SC                                               // SC
    releaseTurn();                                      releaseTurn();
    // NCS                                              // NCS
}                                                   }

getTurn() {                                     releaseTurn(){
 return ticket++;                                   turn++;
}                                               }


a) getTurn () && releaseTurn () NO ATÓMICAS
    MUTEX: No cumple porque ambos threads pueden obtener el mismo myTurn, cuando entra en getTurn() demostrado con la traza en el doc.

    GARANTIA DE ENTRADA: Se cumple ya que ninguno queda bloqueado para siempre. 

b) getTurn() && releaseTurn () SON ATOMICAS
    MUTEX: Se cumple porque es como fetchAndAdd()

    GARANTIA: se cumple porque cuando una sale del SC incrementa el turn, haciendo que eventualmente el otro thread pueda ingresar.

c) Sí, pero se tiene que tener en consideración la memoria para almacenar los threads y un riesgo de overflow.

d) Sí, puede cambiar y romperla porque comenzaría a tener tickets (0..255) de manera ciclica, produciendo duplicidades en myTurn ó generando entradas prematuras.

                                        -----------------------------------------------------------
                                                            EJERCICIO 6 => n threads // APLICA A N THREADS O ACOTADOS
global int[] queue = new int[ n ]; // [1,2,3]

thread {
    id = 1;                                         // ids de 1 a n
    // SNC
    push ( queue , id );                            //atomic: agrega el elemento al final
    while ( id != peek ( queue ));                  //atomic: retorna el elemento al principio
    // SC
    pop ( queue );                                  //atomic: remueve el elemento al principio
    // SNC
}

T1 => push           //[2,3,1]
T2 => push          // [3,1,2]

T1 => while (1 != 3)    => True
        SC
        queue = [1,2]
T2 => while (2 != 1)    => true
      SC
      queue = [2]  
        

MUTEX: si cumple 

GARANTIA DE ENTRADA: si se cumple es como en fetchAndAdd()

                                        -----------------------------------------------------------
                                                            EJERCICIO 7  => N threads

 global LLSC lock = new LLSC(false,-1);

    thread {
        //Seccion No Critica
        LLSC local;
        do {
            do { local = lock.loadLink(); }
            while (local.flag);
        } while (!lock.storeConditional(local, true));
        //Seccion Critica
        lock.reset();
        //Seccion No Critica
    }

   
    class LLSC {
        private boolean flag;           // false
        private long timestamp;         //-1

        public LLSC(boolean flag, long timestamp) {
        this.flag = flag;
        this.timestamp = timestamp;
        }

        public LLSC loadLink() {
            this.timestamp = System.currentTimeMillis();     //NUNCA DEVUELVE EL MISMO VALOR
            return new LLSC(this.flag, this.timestamp);
        }

        public boolean storeConditional(LLSC other, boolean value) {
            if (this.timestamp != other.timestamp)
                return false;
            this.flag = value;
            return true;
        }

        public void reset() {
            this.flag = false;
        }
 }

 a) NO SE CUMPLE MUTEX : porque en loadLink() se crea un nuevo objeto LLSC con copia de flag y un timestamp propio, haciendo que nunca coincida con lock.timestamp
    Entonces el chequeo en storeConditional (this.timestamp != other.timestamp) falla porque otros threads pueden "colarse" antes de que se ejecute el lock.reset() 

 b) NO SE CUMPLE GARANTIA DE ENTRADA: 
        Con cada llamada al loadLink() cambia el lock.timestamp, e invalida cualquier storeConditional() de los demás produciendo deadlock 

 c) loadLink && storeConditional SON ATOMICAS:
    No cambia porque el problema esta en la logica del timestamp que hace que un storeConditional siempre invalide a otro, porque cada loadLink() cambia el timestamp global.
    Haciendo que no se cumpla ni mutex ni la garantia de entrada. 